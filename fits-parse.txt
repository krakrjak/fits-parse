-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse FITS files
--   
--   Parse and manipulate FITS data natively in Haskell
@package fits-parse
@version 0.3.4


-- | Definitions for the data types needed to parse an HDU in a FITS block.
module Data.Fits

-- | This is the main low-level function which parses the data portion of
--   an HDU. You need and element count, a format and a bytestring. The
--   resulting list is produced in column-row major order as specified in
--   the standard.
parsePix :: Int -> BitPixFormat -> ByteString -> IO [Pix]

-- | Remove the Pix wrapper for integer <a>Pix</a> lists.
pixsUnwrapI :: BitPixFormat -> [Pix] -> [Int]

-- | Remove the <a>Pix</a> wrapper for floating point <a>Pix</a> lists.
pixsUnwrapD :: BitPixFormat -> [Pix] -> [Double]

-- | The <a>HeaderDataUnit</a> is the full HDU. Both the header information
--   is encoded alongside the data payload.
data HeaderDataUnit
HeaderDataUnit :: Header -> Dimensions -> Extension -> ByteString -> HeaderDataUnit

-- | The heeader contains metadata about the payload
[_header] :: HeaderDataUnit -> Header

-- | This dimensions of the main data array
[_dimensions] :: HeaderDataUnit -> Dimensions

-- | Extensions may vary the data format
[_extension] :: HeaderDataUnit -> Extension

-- | The main data array
[_mainData] :: HeaderDataUnit -> ByteString
dimensions :: Lens' HeaderDataUnit Dimensions
header :: Lens' HeaderDataUnit Header
extension :: Lens' HeaderDataUnit Extension
mainData :: Lens' HeaderDataUnit ByteString

-- | Following <a>BitPixFormat</a> we have a tag for integer and floating
--   point values. We box them up to ease parsing.
data Pix
PB :: Int -> Pix
PI16 :: Int -> Pix
PI32 :: Int -> Pix
PI64 :: Int -> Pix
PF :: Double -> Pix
PD :: Double -> Pix

-- | The header part of the HDU is vital carrying not only authorship
--   metadata, but also specifying how to make sense of the binary payload
--   that starts 2,880 bytes after the start of the <tt>HeaderData</tt>.
newtype Header
Header :: Map Keyword Value -> Header
[_keywords] :: Header -> Map Keyword Value
keywords :: Lens' Header (Map Keyword Value)
data Extension

-- | Any header data unit can use the primary format. The first MUST be
--   Primary. This is equivalent to having no extension
Primary :: Extension

-- | An encoded image. PCOUNT and GCOUNT are required but irrelevant
Image :: Extension

-- | A Binary table. PCOUNT is the number of bytes that follow the data in
--   the <a>heap</a>
BinTable :: Int -> ByteString -> Extension
[pCount] :: Extension -> Int
[heap] :: Extension -> ByteString
lookup :: Keyword -> Header -> Maybe Value

-- | The <a>Text</a> wrapper for HDU the keyword data for lines of the
--   form: KEYWORD=VALUE
newtype Keyword
Keyword :: Text -> Keyword

-- | <a>Value</a> datatype for discriminating valid FITS KEYWORD=VALUE
--   types in an HDU.
data Value
Integer :: Int -> Value
Float :: Float -> Value
String :: Text -> Value
Logic :: LogicalConstant -> Value
toInt :: Value -> Maybe Int
toFloat :: Value -> Maybe Float
toText :: Value -> Maybe Text

-- | Direct encoding of a <a>Bool</a> for parsing <a>Value</a>
data LogicalConstant
T :: LogicalConstant
F :: LogicalConstant

-- | When we load a header, we parse the BITPIX and NAXIS(N) keywords so we
--   - can know how long the data array is
data Dimensions
Dimensions :: BitPixFormat -> Axes -> Dimensions
[_bitpix] :: Dimensions -> BitPixFormat
[_axes] :: Dimensions -> Axes
axes :: Lens' Dimensions Axes
bitpix :: Lens' Dimensions BitPixFormat
newtype Comment
Comment :: Text -> Comment

-- | The standard defines two possible values for the SIMPLE keyword, T and
--   F. The T refers to a <a>Conformant</a> format while F refers to a
--   <a>NonConformant</a> format. At this time only the <a>Conformant</a>,
--   T, format is supported.
data SimpleFormat
Conformant :: SimpleFormat
NonConformant :: SimpleFormat

-- | The <a>BitPixFormat</a> is the nitty gritty of how the <tt>Axis</tt>
--   data is layed out in the file. The standard recognizes six formats:
--   unsigned 8 bit integer, two's complement binary integers at 16, 32,
--   and 64 bits along with 32 and 64 bit IEEE floating point formats.
data BitPixFormat

-- | BITPIX = 8; unsigned binary integer of 8 bits
EightBitInt :: BitPixFormat

-- | BITPIX = 16; two's complement binary integer of 16 bits
SixteenBitInt :: BitPixFormat

-- | BITPIX = 32; two's complement binary integer of 32 bits
ThirtyTwoBitInt :: BitPixFormat

-- | BITPIX = 64; two's complement binary integer of 64 bits
SixtyFourBitInt :: BitPixFormat

-- | BITPIX = -32; IEEE single precision floating point of 32 bits
ThirtyTwoBitFloat :: BitPixFormat

-- | BITPIX = -64; IEEE double precision floating point of 64 bits
SixtyFourBitFloat :: BitPixFormat

-- | <a>Axes</a> represents the combination of NAXIS + NAXISn. The spec
--   supports up to 999 axes
type Axes = [Int]

-- | This utility functions quickly lets you know if you are dealing with
--   integer data.
isBitPixInt :: BitPixFormat -> Bool

-- | This utility functions quickly lets you know if you are dealing with
--   floating point data.
isBitPixFloat :: BitPixFormat -> Bool

-- | This utility function can be used to get the word count for data in an
--   HDU.
bitPixToWordSize :: BitPixFormat -> Int

-- | This utility function can be used to get the size in bytes of the -
--   format.
bitPixToByteSize :: BitPixFormat -> Int
pixDimsByCol :: Axes -> [Int]
pixDimsByRow :: Axes -> [Int]

-- | A single record in the HDU is an eighty byte word.
hduRecordLength :: Int

-- | The maximum amount of eighty byte records is thirty-six per the
--   standard.
hduMaxRecords :: Int

-- | The size of an HDU block is fixed at thirty-six eighty byte words. In
--   other words 2,880 bytes. These blocks are padded with zeros to this
--   boundary.
hduBlockSize :: Int
instance GHC.Show.Show Data.Fits.HeaderDataUnit
instance Data.String.IsString Data.Fits.Comment
instance GHC.Classes.Ord Data.Fits.Comment
instance GHC.Classes.Eq Data.Fits.Comment
instance GHC.Show.Show Data.Fits.Comment
instance GHC.Classes.Eq Data.Fits.Extension
instance GHC.Classes.Eq Data.Fits.Dimensions
instance GHC.Show.Show Data.Fits.Dimensions
instance GHC.Show.Show Data.Fits.Extension
instance GHC.Show.Show Data.Fits.Header
instance GHC.Show.Show Data.Fits.SimpleFormat
instance GHC.Classes.Eq Data.Fits.SimpleFormat
instance GHC.Classes.Eq Data.Fits.LogicalConstant
instance GHC.Show.Show Data.Fits.LogicalConstant
instance Data.String.IsString Data.Fits.Keyword
instance GHC.Classes.Ord Data.Fits.Keyword
instance GHC.Classes.Eq Data.Fits.Keyword
instance GHC.Show.Show Data.Fits.Keyword
instance GHC.Classes.Eq Data.Fits.Value
instance GHC.Show.Show Data.Fits.Value
instance GHC.Classes.Eq Data.Fits.BitPixFormat
instance GHC.Classes.Eq Data.Fits.Header
instance GHC.Show.Show Data.Fits.BitPixFormat

module Data.Fits.Read

-- | Parse and read all HDUs in the input string
readHDUs :: ByteString -> Either String [HeaderDataUnit]

-- | Parse and read only the Primary HDU from the input string
readPrimaryHDU :: ByteString -> Either String HeaderDataUnit

-- | Look up a keyword and parse it into the expected format
getKeyword :: Text -> (Value -> Maybe a) -> HeaderDataUnit -> Either String a

-- | Get the HDU at an index and fail with a readable error
getHDU :: String -> Int -> [HeaderDataUnit] -> Either String HeaderDataUnit
maybeError :: FitsError -> Maybe a -> Either String a
eitherFail :: MonadFail m => Either String a -> m a
data FitsError
ParseError :: ParseErr -> FitsError
MissingKey :: Keyword -> FitsError
InvalidKey :: Keyword -> Value -> FitsError
MissingHDU :: String -> Int -> FitsError
InvalidData :: String -> FitsError
instance GHC.Classes.Eq Data.Fits.Read.FitsError
instance GHC.Show.Show Data.Fits.Read.FitsError
