-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse FITS files
--   
--   Parse and manipulate FITS data natively in Haskell
@package fits-parse
@version 0.0.1


-- | Definitions for the data types needed to parse an HDU in a FITS block.
module Data.Fits

-- | This is the main low-level function which parses the data portion of
--   an HDU. You need and element count, a format and a bytestring. The
--   resulting list is produced in column-row major order as specified in
--   the standard.
parsePix :: Int -> BitPixFormat -> ByteString -> IO [Pix]

-- | Remove the Pix wrapper for integer <a>Pix</a> lists.
pixsUnwrapI :: BitPixFormat -> [Pix] -> [Int]

-- | Remove the <a>Pix</a> wrapper for floating point <a>Pix</a> lists.
pixsUnwrapD :: BitPixFormat -> [Pix] -> [Double]

-- | The <a>HeaderDataUnit</a> is the full HDU. Both the header information
--   is encoded alongside the <a>Axis</a> payload.
data HeaderDataUnit
HeaderDataUnit :: HeaderData -> ByteString -> HeaderDataUnit

-- | Just the header part of the HDU
[headerData] :: HeaderDataUnit -> HeaderData

-- | The actual data payload
[payloadData] :: HeaderDataUnit -> ByteString

-- | The header part of the HDU is vital carrying not only authorship
--   metadata, but also specifying how to make sense of the binary payload
--   that starts 2,880 bytes after the start of the <a>HeaderData</a>.
data HeaderData
HeaderData :: SimpleFormat -> BitPixFormat -> [Axis] -> StringValue -> StringValue -> StringValue -> StringValue -> StringValue -> StringValue -> StringValue -> StringValue -> HeaderData

-- | SIMPLE
[simpleFormat] :: HeaderData -> SimpleFormat

-- | BITPIX
[bitPixFormat] :: HeaderData -> BitPixFormat

-- | Axes metadata
[axes] :: HeaderData -> [Axis]

-- | OBJECT
[objectIdentifier] :: HeaderData -> StringValue

-- | DATE
[observationDate] :: HeaderData -> StringValue

-- | OBJECT
[originIdentifier] :: HeaderData -> StringValue

-- | TELESCOP
[telescopeIdentifier] :: HeaderData -> StringValue

-- | INSTRUME
[instrumentIdentifier] :: HeaderData -> StringValue

-- | OBSERVER
[observerIdentifier] :: HeaderData -> StringValue

-- | CREATOR
[authorIdentifier] :: HeaderData -> StringValue

-- | REFERENC
[referenceString] :: HeaderData -> StringValue

-- | The <a>BitPixFormat</a> is the nitty gritty of how the <a>Axis</a>
--   data is layed out in the file. The standard recognizes six formats:
--   unsigned 8 bit integer, two's complement binary integers at 16, 32,
--   and 64 bits along with 32 and 64 bit IEEE floating point formats.
data BitPixFormat

-- | BITPIX = 8; unsigned binary integer of 8 bits
EightBitInt :: BitPixFormat

-- | BITPIX = 16; two's complement binary integer of 16 bits
SixteenBitInt :: BitPixFormat

-- | BITPIX = 32; two's complement binary integer of 32 bits
ThirtyTwoBitInt :: BitPixFormat

-- | BITPIX = 64; two's complement binary integer of 64 bits
SixtyFourBitInt :: BitPixFormat

-- | BITPIX = -32; IEEE single precision floating point of 32 bits
ThirtyTwoBitFloat :: BitPixFormat

-- | BITPIX = -64; IEEE double precision floating point of 64 bits
SixtyFourBitFloat :: BitPixFormat

-- | Following <a>BitPixFormat</a> we have a tag for integer and floating
--   point values. We box them up to ease parsing.
data Pix
PB :: Int -> Pix
PI16 :: Int -> Pix
PI32 :: Int -> Pix
PI64 :: Int -> Pix
PF :: Double -> Pix
PD :: Double -> Pix

-- | The standard defines two possible values for the SIMPLE keyword, T and
--   F. The T refers to a <a>Conformant</a> format while F refers to a
--   <a>NonConformant</a> format. At this time only the <a>Conformant</a>,
--   T, format is supported.
data SimpleFormat

-- | Value of SIMPLE=T in the header. <i>supported</i>
Conformant :: SimpleFormat

-- | Value of SIMPLE=F in the header. <i>unsupported</i>
NonConformant :: SimpleFormat

-- | <a>Axis</a> represents a single NAXIS record.
data Axis
Axis :: Int -> Int -> Axis

-- | The axis number under consideration
[axisNumber] :: Axis -> Int

-- | The number of elements in this axis
[axisElementCount] :: Axis -> Int

-- | There are many types of strings defined in the FITS documentation.
--   Refered to as "character string(s)" in the documentation, they can be
--   null, empty, undefined, or contain characters (printable ASCII only).
data StringType

-- | The NULL character string (e.g. AUTHOR=)
NullString :: StringType

-- | An empty string (e.g. AUTHOR="")
EmptyString :: StringType

-- | Plain ASCII data
DataString :: StringType

-- | A <a>StringValue</a> is a type paired with a possible value.
data StringValue
StringValue :: StringType -> Maybe Text -> StringValue

-- | Which <a>StringType</a> is this value?
[stringType] :: StringValue -> StringType

-- | The payload of a character string
[stringValue] :: StringValue -> Maybe Text

-- | The FITS standard allows for the encoding of unsigned integers, signed
--   integers, real numbers, and complex numbers. They are always ASCII
--   encoded. See 5.2 of the standard for more details.
data NumberType

-- | HDU ASCII encoded integer number
IntegerType :: NumberType

-- | HDU ASCII encoded real number
RealType :: NumberType

-- | HDU ASCII encoded complex number
ComplexType :: NumberType

-- | Utility data type to help with the ASCII representation of numbers
data NumberModifier

-- | HDU positive number value
Positive :: NumberModifier

-- | HDU negative number value
Negative :: NumberModifier

-- | HDU numeric value is zero, could be positive or negative
Zero :: NumberModifier

-- | <a>NumberValue</a> contains an encoded numeric record from a data
--   field. This data type still needs to be converted into more useful
--   Haskell data types.
data NumberValue
NumberValue :: NumberType -> NumberModifier -> Text -> Maybe NumberModifier -> Maybe Text -> Maybe NumberModifier -> Maybe Int -> NumberValue

-- | Key to decoding the structure
[numberType] :: NumberValue -> NumberType

-- | Encoding the sign of the real part
[realModifier] :: NumberValue -> NumberModifier

-- | All <a>NumberType</a> have a real part (sign stripped)
[realPart] :: NumberValue -> Text

-- | Encoding the sign of the imaginary part
[imaginaryModifier] :: NumberValue -> Maybe NumberModifier

-- | Only <a>ComplexType</a> have an imaginary part (sign stripped)
[imaginaryPart] :: NumberValue -> Maybe Text

-- | <a>Positive</a>, <a>Negative</a>, or <a>Zero</a>
[exponentModifier] :: NumberValue -> Maybe NumberModifier

-- | All <a>NumberType</a> may have an exponent
[exponent] :: NumberValue -> Maybe Int

-- | This utility functions quickly lets you know if you are dealing with
--   integer data.
isBitPixInt :: BitPixFormat -> Bool

-- | This utility functions quickly lets you know if you are dealing with
--   floating point data.
isBitPixFloat :: BitPixFormat -> Bool

-- | This utility function can be used to get the word count for data in an
--   HDU.
bitPixToWordSize :: BitPixFormat -> Natural

-- | A single record in the HDU is an eighty byte word.
hduRecordLength :: Int

-- | The maximum amount of eighty byte records is thirty-six per the
--   standard.
hduMaxRecords :: Int

-- | The size of an HDU block is fixed at thirty-six eighty byte words. In
--   other words 2,880 bytes. These blocks are padded with zeros to this
--   boundary.
hduBlockSize :: Int
instance Data.Default.Class.Default Data.Fits.HeaderData
instance GHC.Show.Show Data.Fits.BitPixFormat
instance Data.Default.Class.Default Data.Fits.Axis
instance Data.Default.Class.Default Data.Fits.NumberValue
instance Data.Default.Class.Default Data.Fits.StringValue
instance GHC.Show.Show Data.Fits.StringValue
instance GHC.Show.Show Data.Fits.StringType
